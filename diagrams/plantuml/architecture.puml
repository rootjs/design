@startuml

!include ./config/diagramsConfig.puml
!include ./config/classConfig.puml

title
rootJS Architecture

end title

/' ----------------------------------------------------------------------- '/

/' Interfaces '/
interface V8
interface ROOT

/' Environment '/
class "ROOT::TApplication" as TApplication
class NodeApplication << (S,#FF7700) Singleton >>

/' Javascript Prototypes '/
class TemplateFactory
' class TemplateCache

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory
class ProxyFunction

/' Encapsulation of ROOT objects and primitives '/
class "node::ObjectWrap" as ObjectWrap

class ProxyObjectFactory
class ProxyObject

class TemplateProxy
class EnumProxy
class StructProxy
class ArrayProxy
class PointerProxy
class ReferenceProxy

abstract class PrimitiveProxy
class NumberProxy
class StringProxy
class BooleanProxy

/' Interfacing with ROOT's reflection mechanism - i.e. Cling '/
class ClassHelper
class FunctionHelper

/' ----------------------------------------------------------------------- '/

/' Relations '/
TApplication <|-down- NodeApplication

NodeApplication -down-> "1" TemplateFactory
NodeApplication --> "1" ProxyFunctionFactory
NodeApplication --> "1" ProxyObjectFactory

TemplateFactory .left.> V8 : uses
' TemplateFactory -down-> "1" TemplateCache : access

'ClassHelper .up.> ROOT : uses
ClassHelper <-- ProxyObjectFactory

'FunctionHelper .up.> ROOT : uses
FunctionHelper <-- ProxyFunctionFactory

ProxyFunctionFactory .down.> ProxyFunction : creates

ObjectWrap <|-left- ProxyObject

ProxyObjectFactory .down.> ProxyObject : creates
ProxyObject <|-- TemplateProxy
ProxyObject <|-- EnumProxy
ProxyObject <|-- StructProxy
ProxyObject <|-- ArrayProxy
ProxyObject <|-- PointerProxy
ProxyObject <|-- ReferenceProxy

ProxyObject <|-- PrimitiveProxy
PrimitiveProxy <|-- NumberProxy
PrimitiveProxy <|-- StringProxy
PrimitiveProxy <|-- BooleanProxy

/' ----------------------------------------------------------------------- '/

/' Facade '/
class NodeApplication {
  {static} -initialized: bool
  -instance: NodeApplication
  -rootJS: Persistent<Object>
 --
 {static} +ctorCallback(args: FunctionCallbackInfo<Value>)
 {static} +staticCtorCallback(args: FunctionCallbackInfo<Value>)

 {static} +memberGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
 {static} +memberSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
 {static} +memberFunctionCallback(args: FunctionCallbackInfo<Value>)

 {static} +staticGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
 {static} +staticSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
 {static} +staticFunctionCallback(args: FunctionCallbackInfo<Value>)

 {static} +Initialize(exports: Local<Object>, module: Local<Object>)
 {static} -Exit(args: void*)

 {static} +Instance(): NodeApplication

 -NodeApplication(acn: char*, argc: int*, argv: char**) <<constructor>>
 -initROOTGlobals()
 -initROOTMessageCallback()

 -exposeROOT()
 -exposeMacros()
 -exposeClasses()
 -exposeClass(clazz: TClassRef)

 +getIsolate(): Isolate*
 +getExports(): Local<Object>

 +getTemplateFactory(): TemplateFactory
 +getFunctionFactory(): ProxyFunctionFactory
 +getObjectFactory(): ProxyObjectFactory
}

/' ----------------------------------------------------------------------- '/

/' Javascript Prototypes '/
class TemplateFactory {
  -cache: std::map<string, Persistent<FunctionTemplate>>
  --
  +createTemplate(clazz: TClassRef): Local<FunctionTemplate>
}

/'
class TemplateCache {
  -cache: std::map<string, Persistent<FunctionTemplate>>
  --
  +contains(type: TClassRef): bool
  +get(type: TClassRef): Local<FunctionTemplate>
  +store(type: TClassRef, tpl: Local<FunctionTemplate>)
}
'/

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory {
  +createProxyFunction(info: TMethod): ProxyFunciton
  +fromArgs(name: string, clazz: TClassRef, args: FunctionCallbackInfo): ProxyFunction
}

class ProxyFunction {
  -address: void*
  -info: TFunction
  --
  +ProxyFunction(address: void*, info: TFunction) <<constructor>>
  +convertArgs(args: FunctionCallbackInfo): ProxyObject[]
  +call(args: ProxyObject[]): ProxyObject
  +isTemplateFunction(): bool
}

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT objects and primitives '/
class ProxyObjectFactory {
  ' {static} -primitives: map<string, ...>
  --
  +createProxyObject(type: TDataMember, holder: ProxyObject): ProxyObject
}

abstract class ProxyObject {
  #address: void*
  #type: TDataMember
  --
  #ProxyObject(address: void*, type: TDataMember) <<constructor>>
  +getAddress(): void*
  +getType(): TDataMember
  {abstract} +set(value: ProxyObject)
  {abstract} +get(): Local<Value>
  {abstract} +isPrimitive(): bool
}

/' ----------------------------------------------------------------------- '/

/' Interfacing with ROOT's reflection mechanism - i.e. Cling '/
class FunctionHelper {
  -functions: map<string, >
  --
  +GetCallFunc(method: TCppMethod_t): CallFunc_t*
  +copy_args(args_: void*, vargs: void**): void
  +FastCall(method: TCppMethod_t, args_: void*, self: void*, result: void*): Bool_t

  +CallV(method: TCppMethod_t, self: TCppObject_t, args: void*): void
  +CallR(method: TCppMethod_t, self: TCppObject_t, args: void*): void*
  +CallS(method: TCppMethod_t, self: TCppObject_t, args: void*): Char_t*
  +CallO(method: TCppMethod_t, self: TCppObject_t, args: void*, result_type: TCppType_t): TCppObject_t

  +CallConstructor(method: TCppMethod_t, klass: TCppType_t, args: void*): TCppObject_t
  +CallDestructor(type: TCppType_t, self: TCppObject_t): void

  +IsConstructor(method: TCppMethod_t): Bool_t
  +IsPublicMethod(method: TCppMethod_t): Bool_t
  +IsStaticMethod(method: TCppMethod_t): Bool_t
  +IsConstMethod(method: TCppMethod_t): Bool_t
  +IsMethodTemplate(method: TCppMethod_t): Bool_t

  +GetMethodNumTemplateArgs(scope: TCppScope_t, imeth: TCppIndex_t): TCppIndex_t
  +GetMethodTemplateArgName(scope: TCppScope_t, imeth: TCppIndex_t, iarg: TCppIndex_t): std::string

  +GetNumMethods(scope: TCppScope_t): TCppIndex_t
  +GetMethodIndexAt(scope: TCppScope_t, imeth: TCppIndex_t): TCppIndex_t
  +GetMethodsFromName(scope: TCppScope_t, name: std::string&): std::vector<TCppMethod_t>
  +GetMethod(scope: TCppScope_t, imeth: TCppIndex_t): TCppMethod_t
  +GetMethodName(method: TCppMethod_t): std::string
  +GetMethodResultType(method: TCppMethod_t): std::string
  +GetMethodNumArgs(method: TCppMethod_t): TCppIndex_t
  +GetMethodReqArgs(method: TCppMethod_t): TCppIndex_t
  +GetMethodArgName(method: TCppMethod_t, iarg: int): std::string
  +GetMethodArgType(method: TCppMethod_t, iarg: int): std::string
  +GetMethodArgDefault(method: TCppMethod_t, iarg: int): std::string
  +GetMethodSignature(scope: TCppScope_t, imeth: TCppIndex_t): std::string
}

class ClassHelper {
  +IsNamespace(scope: TCppScope_t): Bool_t
  +IsAbstract(klass: TCppType_t): Bool_t
  +IsEnum(type_name: conSTstd::string&): Bool_t
  +IsStruct(type_name: conSTstd::string&): Bool_t

  +GetFinalName(klass: TCppType_t): std::string
  +GetScopedFinalName(klass: TCppType_t): std::string

  +GetNumBases(klass: TCppType_t): TCppIndex_t
  +GetBaseName(klass: TCppType_t, ibase: TCppIndex_t): std::string
  +IsSubtype(derived: TCppType_t, base: TCppType_t): Bool_t

  +GetNumDatamembers(scope: TCppScope_t): TCppIndex_t
  +GetDatamemberName(scope: TCppScope_t, idata: TCppIndex_t): std::string
  +GetDatamemberType(scope: TCppScope_t, idata: TCppIndex_t): std::string
  +GetDatamemberOffset(scope: TCppScope_t, idata: TCppIndex_t): ptrdiff_t
  +GetDatamemberIndex(scope: TCppScope_t, name: conSTstd::string&): TCppIndex_t

  +IsPublicData(scope: TCppScope_t, idata: TCppIndex_t): Bool_t
  +IsStaticData(scope: TCppScope_t, idata: TCppIndex_t): Bool_t
  +IsConstData(scope: TCppScope_t, idata: TCppIndex_t): Bool_t
  +IsEnumData(scope: TCppScope_t, idata: TCppIndex_t): Bool_t

  +resolveAddress(staticMember: TDataMember, clazz: TClassRef): void*
  +resolveAddress(staticMember: TDataMember, clazz: TClassRef): void*
}

@enduml
