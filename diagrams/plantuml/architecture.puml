@startuml

!include ./config/diagramsConfig.puml
!include ./config/classConfig.puml

title
rootJS Architecture

end title

/' ----------------------------------------------------------------------- '/

/' Interfaces '/
interface V8
interface ROOT

/' Environment '/
class "ROOT::TApplication" as TApplication
class NodeApplication << (S,#FF7700) Singleton >>

/' Javascript Prototypes '/
class TemplateFactory
' class TemplateCache

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory
class ProxyFunction

/' Encapsulation of ROOT objects and primitives '/
class "node::ObjectWrap" as ObjectWrap

class ProxyObjectFactory
class ProxyObject

class TemplateProxy
class EnumProxy
class StructProxy
class ArrayProxy
class PointerProxy
class ReferenceProxy

abstract class PrimitiveProxy
class NumberProxy
class StringProxy
class BooleanProxy

/' Interfacing with ROOT's reflection mechanism - i.e. Cling '/
class ClassHelper
class FunctionHelper

/' ----------------------------------------------------------------------- '/

/' Relations '/
TApplication <|-down- NodeApplication

NodeApplication -down-> "1" TemplateFactory
NodeApplication --> "1" ProxyFunctionFactory
NodeApplication --> "1" ProxyObjectFactory

TemplateFactory .left.> V8 : uses
' TemplateFactory -down-> "1" TemplateCache : access

'ClassHelper .up.> ROOT : uses
ClassHelper <-- ProxyObjectFactory

'FunctionHelper .up.> ROOT : uses
FunctionHelper <-- ProxyFunctionFactory

ProxyFunctionFactory .down.> ProxyFunction : creates

ObjectWrap <|-left- ProxyObject

ProxyObjectFactory .down.> ProxyObject : creates
ProxyObject <|-- TemplateProxy
ProxyObject <|-- EnumProxy
ProxyObject <|-- StructProxy
ProxyObject <|-- ArrayProxy
ProxyObject <|-- PointerProxy
ProxyObject <|-- ReferenceProxy

ProxyObject <|-- PrimitiveProxy
PrimitiveProxy <|-- NumberProxy
PrimitiveProxy <|-- StringProxy
PrimitiveProxy <|-- BooleanProxy

/' ----------------------------------------------------------------------- '/

/' Facade '/
class NodeApplication {
  {static} -initialized: bool
  -instance: NodeApplication
  -rootJS: Persistent<Object>
 --
 {static} +ctorCallback(args: FunctionCallbackInfo<Value>)
 {static} +staticCtorCallback(args: FunctionCallbackInfo<Value>)

 {static} +memberGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
 {static} +memberSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
 {static} +memberFunctionCallback(args: FunctionCallbackInfo<Value>)

 {static} +staticGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
 {static} +staticSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
 {static} +staticFunctionCallback(args: FunctionCallbackInfo<Value>)

 {static} +Initialize(exports: Local<Object>, module: Local<Object>)
 {static} -Exit(args: void*)

 {static} +Instance(): NodeApplication

 -NodeApplication(acn: char*, argc: int*, argv: char**) <<constructor>>
 -initROOTGlobals()
 -initROOTMessageCallback()

 -exposeROOT()
 -exposeMacros()
 -exposeClasses()
 -exposeClass(clazz: TClassRef)

 +getIsolate(): Isolate*
 +getExports(): Local<Object>

 +getTemplateFactory(): TemplateFactory
 +getFunctionFactory(): ProxyFunctionFactory
 +getObjectFactory(): ProxyObjectFactory
}

/' ----------------------------------------------------------------------- '/

/' Javascript Prototypes '/
class TemplateFactory {
  -cache: map<string, Persistent<FunctionTemplate>>
  --
  +createTemplate(clazz: TClassRef): Local<FunctionTemplate>
}

/'
class TemplateCache {
  -cache: map<string, Persistent<FunctionTemplate>>
  --
  +contains(type: TClassRef): bool
  +get(type: TClassRef): Local<FunctionTemplate>
  +store(type: TClassRef, tpl: Local<FunctionTemplate>)
}
'/

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory {
  +createProxyFunction(info: TMethod): ProxyFunciton
  +fromArgs(name: string, clazz: TClassRef, args: FunctionCallbackInfo): ProxyFunction
}

class ProxyFunction {
  -address: void*
  -info: TFunction
  --
  +ProxyFunction(address: void*, info: TFunction) <<constructor>>
  +convertArgs(args: FunctionCallbackInfo): ProxyObject[]
  +call(args: ProxyObject[]): ProxyObject
  +isTemplateFunction(): bool
}

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT objects and primitives '/
class ProxyObjectFactory {
  ' {static} -primitives: map<string, ...>
  --
  +createProxyObject(type: TDataMember, holder: ProxyObject): ProxyObject
}

abstract class ProxyObject {
  #address: void*
  #type: TDataMember
  --
  #ProxyObject(address: void*, type: TDataMember) <<constructor>>
  +getAddress(): void*
  +getType(): TDataMember
  {abstract} +set(value: ProxyObject)
  {abstract} +get(): Local<Value>
  {abstract} +isPrimitive(): bool
}

/' ----------------------------------------------------------------------- '/

/' Interfacing with ROOT's reflection mechanism - i.e. Cling '/
class FunctionHelper {
  -functions: map<string, >
  --
  +GetCallFunc(method: TCppMethod): CallFunc*
  +copy_args(args_: void*, vargs: void**): void
  +FastCall(method: TCppMethod, args_: void*, self: void*, result: void*): bool

  +CallV(method: TCppMethod, self: TCppObject, args: void*): void
  +CallR(method: TCppMethod, self: TCppObject, args: void*): void*
  +CallS(method: TCppMethod, self: TCppObject, args: void*): Char*
  +CallO(method: TCppMethod, self: TCppObject, args: void*, resultype: TCppType): TCppObject

  +CallConstructor(method: TCppMethod, klass: TCppType, args: void*): TCppObject
  +CallDestructor(type: TCppType, self: TCppObject): void

  +IsConstructor(method: TCppMethod): bool
  +IsPublicMethod(method: TCppMethod): bool
  +IsStaticMethod(method: TCppMethod): bool
  +IsConstMethod(method: TCppMethod): bool
  +IsMethodTemplate(method: TCppMethod): bool

  +GetMethodNumTemplateArgs(scope: TCppScope, imeth: TCppIndex): TCppIndex
  +GetMethodTemplateArgName(scope: TCppScope, imeth: TCppIndex, iarg: TCppIndex): string

  +GetNumMethods(scope: TCppScope): TCppIndex
  +GetMethodIndexAt(scope: TCppScope, imeth: TCppIndex): TCppIndex
  +GetMethodsFromName(scope: TCppScope, name: string): vector<TCppMethod>
  +GetMethod(scope: TCppScope, imeth: TCppIndex): TCppMethod
  +GetMethodName(method: TCppMethod): string
  +GetMethodResultType(method: TCppMethod): string
  +GetMethodNumArgs(method: TCppMethod): TCppIndex
  +GetMethodReqArgs(method: TCppMethod): TCppIndex
  +GetMethodArgName(method: TCppMethod, iarg: int): string
  +GetMethodArgType(method: TCppMethod, iarg: int): string
  +GetMethodArgDefault(method: TCppMethod, iarg: int): string
  +GetMethodSignature(scope: TCppScope, imeth: TCppIndex): string
}

class ClassHelper {
  +IsNamespace(scope: TCppScope): bool
  +IsAbstract(klass: TCppType): bool
  +IsEnum(type_name: string): bool
  +IsStruct(type_name: string): bool

  +GetFinalName(klass: TCppType): string
  +GetScopedFinalName(klass: TCppType): string

  +GetNumBases(klass: TCppType): TCppIndex
  +GetBaseName(klass: TCppType, ibase: TCppIndex): string
  +IsSubtype(derived: TCppType, base: TCppType): bool

  +GetNumDatamembers(scope: TCppScope): TCppIndex
  +GetDatamemberName(scope: TCppScope, idata: TCppIndex): string
  +GetDatamemberType(scope: TCppScope, idata: TCppIndex): string
  +GetDatamemberOffset(scope: TCppScope, idata: TCppIndex): ptrdiff
  +GetDatamemberIndex(scope: TCppScope, name: string): TCppIndex

  +IsPublicData(scope: TCppScope, idata: TCppIndex): bool
  +IsStaticData(scope: TCppScope, idata: TCppIndex): bool
  +IsConstData(scope: TCppScope, idata: TCppIndex): bool
  +IsEnumData(scope: TCppScope, idata: TCppIndex): bool

  +resolveAddress(staticMember: TDataMember, clazz: TClassRef): void*
  +resolveAddress(staticMember: TDataMember, clazz: TClassRef): void*
}

@enduml
