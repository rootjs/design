@startuml

!include ./config/diagramsConfig.puml
!include ./config/classConfig.puml

title
rootJS Architecture

end title

/' ----------------------------------------------------------------------- '/

/' Interfaces '/
interface ROOT

/' Environment '/
class "ROOT::TApplication" as TApplication
class NodeApplication
class CallbackHandler
class NodeHandler

/' Javascript Prototypes '/
class TemplateFactory
' class TemplateCache

/' Encapsulation '/
abstract class Proxy

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory
class ProxyFunction

/' Encapsulation of ROOT objects and primitives '/
class ProxyObjectFactory
class ProxyObject

class TemplateProxy
class EnumProxy
class StructProxy
class ArrayProxy
class PointerProxy
class ReferenceProxy

abstract class PrimitiveProxy
class NumberProxy
class StringProxy
class BooleanProxy

/' Interfacing with ROOT's reflection mechanism - i.e. Cling '/

/' ----------------------------------------------------------------------- '/

/' Relations '/
TApplication <|-down- NodeApplication
NodeHandler -right-> "1" NodeApplication

CallbackHandler ..> TemplateFactory : uses
CallbackHandler ..> ProxyObjectFactory : uses
CallbackHandler ..> ProxyFunctionFactory : uses

NodeHandler ..> TemplateFactory : uses
NodeHandler ..> ProxyObjectFactory : uses
NodeHandler ..> ProxyFunctionFactory : uses

Proxy <|-right- ProxyObject
Proxy <|-left- ProxyFunction

ProxyFunctionFactory .down.> ProxyFunction : creates
ProxyObjectFactory .down.> ProxyObject : creates

ProxyObject <|-- TemplateProxy
ProxyObject <|-- PrimitiveProxy
PrimitiveProxy <|-- NumberProxy
PrimitiveProxy <|-- StringProxy
PrimitiveProxy <|-- BooleanProxy

/' ----------------------------------------------------------------------- '/

/' Callback Handling '/
class CallbackHandler {
  --
  {static} +ctorCallback(args: FunctionCallbackInfo<Value>)
  {static} +staticCtorCallback(args: FunctionCallbackInfo<Value>)

  {static} +memberGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
  {static} +memberSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
  {static} +memberFunctionCallback(args: FunctionCallbackInfo<Value>)

  {static} +staticGetterCallback(property: Local<String>, info: PropertyCallbackInfo<Value>)
  {static} +staticSetterCallback(property: Local<String>, value: Local<Value>, info: PropertyCallbackInfo<Value>)
  {static} +staticFunctionCallback(args: FunctionCallbackInfo<Value>)
}

class NodeHandler {
  -rootJS: Persistent<Object>
  --
  -exposeROOT()
  -exposeGlobalFunctions()
  -exposeGlobals()
  -exposeMacros()
  -exposeClasses()
  -exposeClass(clazz: TClassRef)

  +getExports(): Local<Object>
}


/' Facade '/
class NodeApplication {
 --
 {static} -Exit(args: void*)

 +NodeApplication(acn: char*, argc: int*, argv: char**) <<constructor>>
 -initROOTGlobals()
 -initROOTMessageCallback()
}

/' ----------------------------------------------------------------------- '/

/' Javascript Prototypes '/
class TemplateFactory {
  {static} -cache: map<string, Persistent<FunctionTemplate>>
  --
  -TemplateFactory() <<constructor>>
  {static} +createTemplate(clazz: TClassRef): Local<FunctionTemplate>
}

/' ----------------------------------------------------------------------- '/

/' Encapsulation '/
abstract class Proxy {
    #address: void*
    #type: TObject
    #scope: TClassRef
    --
    #Proxy(address: void*, type: TObject, scope: TClassRef) <<constructor>>
    {abstract} +setAddress(address: void*)
    +getAddress(): void*
    +getType(): TObject
    +getScope(): TClassRef

    +isGlobal(): bool

    {abstract} +isTemplate(): bool
    {abstract} +isConst(): bool
    {abstract} +isStatic(): bool
}

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT functions '/
class ProxyFunctionFactory {
  -ProxyFunctionFactory() <<constructor>>
  {static} +createProxyFunction(function: TFunction, scope: TClassRef): ProxyFunciton
  {static} +fromArgs(name: string, scope: TClassRef, args: FunctionCallbackInfo): ProxyFunction
}

class ProxyFunction {
  {static} -functions: map<TFunction*, CallFunc*>
  --
  {static} -processCall(method: TFunction*, args: void*, self: void*, result: void*): bool

  {static} -callConstructor(method: TFunction*, type: TClassRef, args: void*): void*
  {static} -callDestructor(type: TClassRef, self: void*): void

  {static} -callObject(method: TFunction*, self: void*, args: void*, resType: TClassRef): void*
  {static} <T> -callPrimitive(TFunction* method, void* self, void* args): T

  {static} +getCallFunc(method: TFunction*): CallFunc*
  {static} +getMethodsFromName(scope: TClassRef, name: string): vector<TFunction*>

  +ProxyFunction(address: void*, function: TFunction, scope: TClassRef) <<constructor>>
  +getType(): TFunction

  +validateArgs(args: FunctionCallbackInfo): ProxyObject[]
  +call(args: ProxyObject[]): ProxyObject

}

/' ----------------------------------------------------------------------- '/

/' Encapsulation of ROOT objects and primitives '/
class ProxyObjectFactory {
  --
  -ProxyObjectFactory() <<constructor>>
  {static} +createProxyObject(type: TDataMember, scope: TClassRef, holder: ProxyObject): ProxyObject
}

class ProxyObject {
  #proxy: Persistent<Object>
  --
  +ProxyObject(type: TDataMember, scope: TClassRef) <<constructor>>
  +getType(): TDataMember

  {abstract} +set(value: ProxyObject)
  {abstract} +get(): Local<Value>

  {abstract} +setProxy(proxy: Local<Object>)
  {abstract} +getProxy(): Local<Object>

  {abstract} +isPrimitive(): bool
}

@enduml
