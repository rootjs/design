\chapter{ROOTPrototype}
The \textit{ROOTPrototype} class is the main entry point of the bindings, during the initialisation phase it exposes all functions, classes and variables to node, further it contains the proxy methods called by node
\section{initialize}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::initialize(Local<Object> exports))} \\
  \hline
  \textit{Visibility} & Public \\
  \hline
  \textit{Parameters} & \textbf{exports}: exports object from the node framework, all methods and variables created in the scope of this object will be available in the node program \\
  \hline
  \textit{Return value} & \textit{none} functions and variables will be attached to the exports object \\
  \hline
  \textit{behavior} & Creates a NodeApplication and calls the private expose methods \\
  \hline
\end{longtable}
This is the function that is beeing called when the modeule in required in node, it is beeing refered to, from the node macro
\begin{verbatim}
NODE_MODULE(rootJS, initialize)
\end{verbatim}
Where rootJS is the name of the node module and initialize is a pointer to the function defined in this section.
\newpage

\section{getListOfClasses}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::getListOfClasses()} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textit{none} \\
  \hline
  \textit{Return value} & \textbf{TCollection} of \textbf{TClass} A collection containing all classes available in the ROOT framework \\
  \hline
  \textit{behavior} & The Cling interpreter is scanned for classes, the result \\
  \hline
\end{longtable}

During the specification phase we decided to use \textit{TRoot::GetListOfClasses}\footnote{\url{https://root.cern.ch/doc/master/classTROOT.html\#abc882c118c351b40f8b96de4afabe5f7}} to retrive a list of all classes that should be available in the node interpreter.
The method returns a \textit{TCollection}, containing \textit{TClass}es.
\textit{TClass} provides all information needed to generate JavaScript objects by using methods like \textit{GetListOfMethods}.

It turned out that \textit{TRoot::GetListOfClasses} only returns a few classes.
To work around this issue PyROOT uses gInterpreter in case the class does not exist in the \textit{TCollection}.
While instantiating a node module a JavaScript object is provided that will be filled with methods or variables during the module initialisation.
Methods that are not bound to the JavaScript object during this phase will not be callable, we are not able to handle class initialisations of classes which are not in the \textit{TRoot::GetListOfClasses} collection because we do not know they are there before a user calls them.
Whereas the python bindings fire up the intperpreter when an unknown class sould be instantiated.

When running the ROOT interactive interpreter TRint\footnote{\url{https://root.cern.ch/doc/master/classTRint.html}} all classes can be found using the autocompletion feature.
Looking at the source code, it turned out to use \textit{gInterpreter-\textgreater GetMapfile()-\textgreater GetTable()} to retrive a list of all the classes and \textit{gClassTable}\footnote{\url{https://root.cern.ch/doc/master/classTClassTable.html}} which is a HashMap, to retrive the corresponding \textit{TClass} objects.

With this approach we have access to all classes that can be accessed by Cling - we would therefore support the same set of features the ROOT interactive interpreter does.
\\
\\
\textcolor{red}{Check if \textit{gClassTable} contains all classes from \textit{gROOT-\textgreater GetListOfClasses}, can we drop \textit{gROOT-\textgreater GetListOfClasses} completely?}
\newpage
\section{exposeClasses}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::exposeClasses(Local<Object> exports)} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textbf{exports}: exports object from the node framework, all methods and variables created in the scope of this object will be available in the node program \\
  \hline
  \textit{Return value} & \textit{none} \\
  \hline
  \textit{behavior} & After running this method all class constructors are added to the exports object \\
  \hline
\end{longtable}


For every ROOT class we run
\begin{verbatim}
NODE_SET_METHOD(exports, className, classProxy)
\end{verbatim}

\textbf{exports} is the JavaScript object which we can use to pass methods and data to node \\
\textbf{className} is the name of the class in the current iteration\\
\textbf{classProxy} is the function that should be called everytime a class is constructed via JavaScript\\
\\
All constructors are now available using the exports object.
\newpage
\section{classProxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::classProxy(const v8::FunctionCallbackInfo<v8::Value>\& args)} \\
  \hline
  \textit{Visibility} & Public \\
  \hline
  \textit{Parameters} & \textbf{args}: arguments passed by node \\
  \hline
  \textit{Return value} & \textit{none}, return value will be passed via the \textbf{args} object \\
  \hline
  \textit{behavior} & The passed arguments will be converted to C++ native arguments or root objects, the list of all classes will be checked for a class with the given name. A matching constructor will be selected and called.
  If the last parameter is a JavaScript function, it will be used as a callback and the call does not block and calls the callback function after finishing.
  Results will be converted to JavaScript objects or natives. \\
  \hline
  \textit{Exceptions} & In case there is no matching constructor, an exception will be thrown.
  Exceptions from ROOT will be forwarded \\
  \hline
\end{longtable}
We only use one proxy for every class to minimize overhead. This is possible because we can store data in a secret area that is not visible via JavaScript, in there we will store data describing the constructor call.
The other option would be to have a proxy class, containing the proxy method and meta information (like the class name or a TClass reference).
The proxy method of a concrete object would then be exported to JavaScript.

This would not be faster as we use hashing to find classes, but would consume more memory.
\newpage
\section{getListOfFunctions}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::getListOfFunctions()} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textit{none} \\
  \hline
  \textit{Return value} & \textbf{TCollection} of \textbf{TFunction} A collection containing all functions available in the ROOT framework \\
  \hline
  \textit{behavior} & gROOT->GetListOfGlobalFunctions will be used to get the TCollection \\
  \hline
\end{longtable}
This method will more or less bypass the results of \textit{gROOT->GetListOfGlobalFunctions} and is only there if we run into a situation where we need to manipulate the collection before exporting the functions.
\newpage
\section{exposeFunctions}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::exposeFunctions(Local<Object> exports)} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textbf{exports}: exports object from the node framework, all methods and variables created in the scope of this object will be available in the node program \\
  \hline
  \textit{Return value} & \textit{none} \\
  \hline
  \textit{behavior} & After running this method all functions are added to the exports object \\
  \hline
\end{longtable}

For every global function we run
\begin{verbatim}
NODE_SET_METHOD(exports, functionName, functionProxy)
\end{verbatim}

\textbf{exports} is the JavaScript object which we can use to pass methods and data to node \\
\textbf{functionName} is the name of the function in the current iteration\\
\textbf{functionProxy} is the function that should be called everytime a class is constructed via JavaScript\\
\\
All functions are now available using the exports object.
\newpage
\section{functionProxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::functionProxy(const v8::FunctionCallbackInfo<v8::Value>\& args)} \\
  \hline
  \textit{Visibility} & Public \\
  \hline
  \textit{Parameters} & \textbf{args}: arguments passed by node \\
  \hline
  \textit{Return value} & \textit{none}, return value will be passed via the \textbf{args} object \\
  \hline
  \textit{behavior} & The passed arguments will be converted to C++ native arguments or root objects, the list of all functions will be checked for a function with the given name. 
  A overloaded version of the function with correct parameters will be searched, and called. The results will be converted to JavaScript objects. \\
  \hline
  \textit{Exceptions} & In case there is no function with a matching signature, an exception will be thrown.
  Exceptions from ROOT will be forwarded \\
  \hline
\end{longtable}
This is possible because we can store data in a secret area that is not visible via JavaScript, in there we will store data describing the function call.
\newpage
\section{getListOfVariables}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::getListOfVariables()} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textit{none} \\
  \hline
  \textit{Return value} & \textbf{TCollection} of \textbf{TGlobal} A collection containing all globally available variables in the ROOT framework \\
  \hline
  \textit{behavior} & gROOT->GetListOfGlobals will be used to get the TCollection \\
  \hline
\end{longtable}
This method will more or less bypass the results of \textit{gROOT->GetListOfGlobals} and is only there if we run into a situation where we need to manipulate the collection before exporting the variables.
\newpage
\section{exposeVariables}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::exposeVariables(Local<Object> exports)} \\
  \hline
  \textit{Visibility} & Private \\
  \hline
  \textit{Parameters} & \textbf{exports}: exports object from the node framework, all methods and variables created in the scope of this object will be available in the node program \\
  \hline
  \textit{Return value} & \textit{none} \\
  \hline
  \textit{behavior} & After running this method all global variables are added to the exports object, by creating a getter and a setter function \\
  \hline
\end{longtable}

For every global variable we create an ObjectTemplate and use v8::Template::SetNativeDataProperty to set getters and setters for the variable (see getterProxy and setterProxy).
The Object generated from the ObjectTemplate is beeing attached to the exports object.

\newpage
\section{getterProxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::getterProxy(const v8::FunctionCallbackInfo<v8::Value>\& args)} \\
  \hline
  \textit{Visibility} & Public \\
  \hline
  \textit{Parameters} & \textbf{args}: arguments passed by node, will be ignored \\
  \hline
  \textit{Return value} & \textit{none}, return value will be passed via the \textbf{args} object \\
  \hline
  \textit{behavior} & The global variable will be read and converted to a JavaScript object\\
  \hline
  \textit{Exceptions} & In case the variable is not readable (e.g. not initialized), null will be returned \\
  \hline
\end{longtable}
We only use one proxy for every setter to minimize overhead. This is possible because we can store data in a secret area that is not visible via JavaScript, in there we will store data describing the getter call.
\newpage
\section{setterProxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
  \hline
  \textit{Name} & \texttt{ROOTPrototype::setterProxy(const v8::FunctionCallbackInfo<v8::Value>\& args)} \\
  \hline
  \textit{Visibility} & Public \\
  \hline
  \textit{Parameters} & \textbf{args}: first argument will be used \\
  \hline
  \textit{Return value} & \textit{none} \\
  \hline
  \textit{behavior} & The parameter in the args object will be converted to a C++ variable, it will be saved in the global variable\\
  \hline
  \textit{Exceptions} & In case the variable has a wrong type an Exception will be thrown \\
  \hline
\end{longtable}
We only use one proxy for every setter to minimize overhead. This is possible because we can store data in a secret area that is not visible via JavaScript, in there we will store data describing the setter call.
\newpage
\section{additional private methods}
\begin{itemize}
  \item createGetterName(std::string name) will change the first character of name to uppercase and prepend get (e.g. name: app, result: getApp)
  \item createSetterName(std::string name) will change the first character of name to uppercase and prepend set (e.g. name: app, result: setApp)
\end{itemize}
\section{additional public methods}
\begin{itemize}
  \item A sync method might be needed when new classes can be created during runtime, \color{red}{need to evaluate this}!
\end{itemize}
