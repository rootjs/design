\chapter{Proxy}
The \textit{Proxy} class is an abstract class which acts as an intermediary between Node.js and ROOT. Both the
\textit{ObjectProxy} and \textit{FunctionProxy} inherit the \textit{Proxy} class. Both of them require the object's or
function's \textit{void*} address to access the original ROOT object. The \textit{TObject} type is more accurately
specified in each class which inherits \textit{Proxy}. The \textit{TClassRef} scope is used to access \textit{TClass}
and the necessary information about the class. The \textit{Proxy} class holds the data, which both
\textit{ObjectProxy} and \textit{FunctionProxy} require.\\

A getter and a setter method can be set by calling \textit{v8::ObjectTemplate::SetAccessor} with Node.js, so when a value is assigned to a property, which is encapsulated by the bindings, a setter will be called.
This setter will retrieve the \textit{Proxy}, which has been stored in an internal field which is bound to the JavaScript object. The \textit{Proxy} is used to write the new data to the specific memory address, after making sure the property is writable.

\section{Proxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::Proxy(address: void*, type: TObject, scope: TClassRef)}\\
\hline
 \textit{Visibility} & protected\\
\hline
\textit{Parameters} & \textit{address: void*} The memory address of the ROOT object \\
& \textit{type: TObject}  The type of Object will be specified in the subclasses \\
& \textit{scope: TClassRef} The reference of the TClass so that it can be accessed  \\
\hline
\textit{Return value} & \textbf{<<constructor>>} Returns a Proxy with the given parameters as a variables \\
  \hline
 \textit{Behavior} & The Proxy constructor will be inherited by both ObjectProxy and FunctionProxy.
 The created Proxy will have the parameters as variables. \\
\hline
\end{longtable}
 \section{setAddress}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::setAddress(address: void*)}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{address: void*} The address to which the proxied ROOT object should be set to \\
\hline
\textit{Return value} & \textbf{none}\\
  \hline
 \textit{Behavior} & Sets the address of the proxied ROOT object. \\
\hline
\end{longtable} \pagebreak
 \section{getAddress}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::getAddress()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{void*} The current address of the proxied ROOT object \\
  \hline
 \textit{Behavior} & Gets the current address of the proxied ROOT object. \\
\hline
\end{longtable}
 \section{getType}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::getType()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{TObject} The current type of the proxied ROOT object \\
  \hline
 \textit{Behavior} & Gets the current type of the proxied ROOT object. \\
\hline
\end{longtable}
 \section{getScope}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::getScope()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{TClassRef} The current scope of the proxied ROOT object \\
  \hline
 \textit{Behavior} & Gets the current scope of the proxied ROOT object. \\
\hline
\end{longtable} \pagebreak
 \section{isGlobal}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::isGlobal()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{bool} True if the proxied object is global \\
  \hline
 \textit{Behavior} & Checks if a global element (not an object member or a static class member) is proxied. \\
\hline
\end{longtable}
 \section{isTemplate}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::isTemplate()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{bool} True if the Proxy is a template \\
  \hline
 \textit{Behavior} & Checks if the Proxy is a template, which allows using generic types. \\
\hline
\end{longtable}
 \section{isConst}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::isConst()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{bool} True if the proxied value is a constant \\
  \hline
 \textit{Behavior} & Checks if the proxied value is a constant. \\
\hline
\end{longtable} \pagebreak
 \section{isStatic}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{Proxy::isStatic()}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{none}\\
\hline
\textit{Return value} & \textbf{bool} True if the proxied value is static \\
  \hline
 \textit{Behavior} & Checks if the proxied value is static. \\
\hline
\end{longtable} \pagebreak
