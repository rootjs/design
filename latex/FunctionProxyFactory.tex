\chapter{FunctionProxyFactory}
The \textit{FunctionProxyFactory} creates \textit{FunctionProxy} objects. It differentiates between ROOT functions that can be overloaded and those that can't be.
\section{createFunctionProxy}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline
\textit{Name} & \texttt{FunctionProxyFactory::createFunctionProxy(function: TFunction, scope: TClassRef)}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{function: TFunction} The ROOT function to be proxied. \\ 
& \textit{scope: TClassRef} The scope of the function.\\
\hline
\textit{Return value} & \textbf{FunctionProxy} the proxied function\\
  \hline
 \textit{Behavior} & A simple method to create \textit{FunctionProxy} objects for a given function in a given scope. This is used if there is no overloading or a \textit{TFunction} is given directly.\\
\hline
\end{longtable} 
 \section{fromArgs}
\begin{longtable}{p{3cm} @{\hskip 1cm} p{12cm}}
 \hline	
\textit{Name} & \texttt{FunctionProxyFactory::fromArgs(name: string, scope: TClassRef, args: FunctionCallbackInfo)}\\
\hline
 \textit{Visibility} & public\\
\hline
\textit{Parameters} & \textit{name: string} The name of the ROOT function \\ & \textit{scope: TClassRef} The reference to the holding class that is searched for the function \\ &\textit{args: FunctionCallbackInfo} The arguments read from the \textit{CallbackHandler}\\
\hline
\textit{Return value} & \textbf{FunctionProxy} The proxied ROOT function\\
  \hline
 \textit{Behavior} & This method is used to deal with overloaded functions, since JavaScript doesn't support it. It searches the given scope for a function with the given names and arguments and throws an exception if nothing is found.\\
\hline
\end{longtable} \pagebreak
